<link rel="import" href="imports.html">

<!--
`lrnsys-progress`
A LRN element

@demo demo/index.html
-->

<dom-module id="lrnsys-progress">
  <template>
    <style>
      :host {
        display: block;
      }
      #circle-container {
        display: flex;
        justify-content:space-between;
        list-style: none;
        margin: -1.4em 0 0 0;
        padding: 0;
      }
      paper-progress {
        --paper-progress-height: .5em;
        --paper-progress-transition-duration: 0.5s;
        --paper-progress-transition-timing-function: ease;
        --paper-progress-transition-delay: .4s;
        width: 100%;
      }
      lrnsys-progress-circle {
        --lrnsys-progress-circle-size: 2.5em;
      }
    </style>
    <iron-ajax
       id="ajax"
       url="[[activeNodeURL]]"
       handle-as="json"
       last-response="{{nodeData}}"
       on-response="handleNodeResponse"></iron-ajax>
    <h3 hidden>[[title]]</h3>
    <paper-progress id="progress" value="[[overallPercentage]]"></paper-progress>
    <ul id="circle-container">
      <template is="dom-repeat" items="[[items]]" as="item">
        <li class="circle-node">
          <lrnsys-progress-circle active="[[_isActive(index, active)]]" step="[[index]]" label="[[item.title]]" icon="[[item.icon]]" icon-complete="[[item.iconComplete]]" data-url="[[item.dataUrl]]" url="[[item.url]]" status="[[item.status]]" value="[[item.value]]" max="[[item.max]]" width="4"></lrnsys-progress-circle>
        </li>
      </template>
    </ul>

  </template>

  <script>
    Polymer({
      is: 'lrnsys-progress',
      listeners: {
        'node-is-active': '_activeChanged',
        'node-status-change': '_statusChanged',
      },
      properties: {
        /**
         * Items to display to visualize the progression.
         */
        items: {
          type: Array,
          value: [],
          notify: true,
          observer: "_itemsChanged",
        },
        /**
         * Title of this progression, primarily for accessibility.
         */
        title: {
          type: String,
          value: 'Steps to completion',
          reflectToAttribute: true,
        },
        /**
         * Items displayed at specific points on the progression.
         * These aren't filled up but place points along the progression
         * which can help people see where they are relative to other
         * factors such as % complete as a tick mark or icon.
         */
        keyItems: {
          type: Array,
          value: [],
          notify: true,
        },
        /**
         * ID of the active item.
         */
        active: {
          type: Number,
          value: 0,
          reflectToAttribute: true,
        },
        /**
         * Whether to automatically make disabled items available
         * or not when the previous one was just complete.
         */
        progressiveUnlock: {
          type: Boolean,
          value: true,
          reflectToAttribute: true,
          notify: true,
        },
        /**
         * State of progress in the current progression
         */
        state: {
          type: String,
          reflectToAttribute: true,
        },
        /**
         * How far is the user through this series of items.
         */
        overallPercentage: {
          type: Number,
          computed: "_overallPercentageCompute(items, active)",
          reflectToAttribute: true,
        },
        /**
         * Responses for each item.
         */
        _responseList: {
          type: Array,
          value: []
        },
        /**
         * Active response from the node selected.
         */
        activeNodeResponse: {
          type: String,
          value: "",
          observer: "_activeResponseChange",
        },
        /**
         * Active response from the node selected.
         */
        nodeData: {
          type: Object,
          value: [],
        },
      },
      /**
       * Notice items have changed; only worry about if the count changes
       * though since other oberservers handle downstream mutation
       */
      _itemsChanged: function(newValue, oldValue) {
        // strange but this is effectively the same as "ready" except the ready
        // state invokes potentially without items while this one will only
        // match a case where there was no values and now we have one
        if (typeof oldValue !== typeof undefined && newValue.length != oldValue.length && typeof this._responseList[this.active] === typeof undefined) {
          this.items[this.active].status = 'loading';
          this.set('items.' + this.active +'.status', 'loading');
          // becasue this is so early in bootstrap of the element we
          // won't be able to detect the initial loading event
          this.$.ajax.url = this.items[this.active].dataUrl;
          this.$.ajax.generateRequest();
        }
      },
      /**
       * Simple boolean for whatever is active currently.
       */
      _isActive: function (index, active) {
        return index === active;
      },
      /**
       * Active Response changed; bubble it up.
       */
      _activeResponseChange: function (value) {
        this.fire('progress-response-loaded', {response: value});
      },
      /**
       * Active item has changed, set the rest of the data to match.
       */
      _activeChanged: function (e) {
        this.active = e.target.step;
        this.items.forEach((element, index, array) => {
          if (this.items[index].status == 'disabled') {
            // do nothing, it's disabled unless....
            if (index != 0 && this.progressiveUnlock && this.items[index-1].status == 'complete') {
              this.items[index].status = 'loading'
              this.set('items.' + index +'.status', 'loading');
            }
          }
          else if (this.items[index].value == this.items[index].max) {
            this.items[index].status = 'complete'
            this.set('items.' + index +'.status', 'complete');
          }
          else if (index == this.active) {
            // see if we have the data for it already
            if (typeof this._responseList[index] === typeof undefined) {
              this.items[index].status = 'loading'
              this.set('items.' + index +'.status', 'loading');
            }
            else {
              this.activeNodeResponse = this._responseList[index];
              this.items[index].status = 'available'
              this.set('items.' + index +'.status', 'available');
            }
          }
          else {
            this.items[index].status = 'available'
            this.set('items.' + index +'.status', 'available');
          }
        });
      },
      /**
       * Listen for the state of anything below to change.
       */
      _statusChanged: function (e) {
        // we are in loading state so go load data and let the response
        // dictate what state we reach after that
        if (e.target.status == 'loading') {
          this.$.ajax.url = this.items[this.active].dataUrl;
          this.$.ajax.generateRequest();
        }
      },
      /**
       * Response returned from triggering the Node's URL to fire to get a response.
       */
      handleNodeResponse: function (e) {
        const detail = e.detail;
        // this means that it was an internal path, fake "loading"
        if (typeof detail.response === typeof null) {
          setTimeout( () => {
            this.items[this.active].status = 'available'
            this.set('items.' + this.active +'.status', 'available');
            this._responseList[this.active] = detail.response;
            this.activeNodeResponse = this._responseList[this.active];
          }, 1500);
        }
        // valid response, pass it along for other things to use
        else if (detail.response.status === 200) {
          this.items[this.active].status = 'available'
          this.set('items.' + this.active +'.status', 'available');
          this._responseList[this.active] = detail.response;
          this.activeNodeResponse = this._responseList[this.active];
        }
        else {
          // fire an event that this isn't really available so we know an issue occured
          this.fire('node-load-failed', {node: this.items[this.active]});
          // @todo, need support for a failed to load state; could be useful
          // if we go into an offline capability in the future
          this.items[this.active].status = 'available'
          this.set('items.' + this.active +'.status', 'available');
        }
      },
      /**
       * Calculate the overall percentage competed.
       * This forms the line that's connecting the steps.
       */
      _overallPercentageCompute: function (items, active) {
        this.$.progress.classList.add('transiting');
        this.state = 'active item is ' + active;
        this.fire('progress-state-change', {state: this.state, active: items[active]});
        return (active / (items.length-1)) * 100;
      },
      /**
       * Change the percentage for the active item.
       */
      changePercentage: function (percentage, mode) {
        var newp = 0;
        if (mode == 'add') {
          newp = this.items[this.active].value + percentage;
        }
        else if (mode == 'subtract') {
          newp = this.items[this.active].value - percentage;
        }
        else {
          newp = percentage;
        }
        if (newp >= this.items[this.active].max) {
          this.set('items.' + this.active +'.value', this.items[this.active].max);
          this.set('items.' + this.active +'.status', 'complete');
          // ensure we still have more items to go in the list
          if (this.items.length > (this.active + 1)) {
            // if we have progressive unlocking then set the next thing available
            if (this.active != 0 && this.progressiveUnlock && this.items[this.active].status == 'complete' && this.items[this.active+1].status == 'disabled') {
              this.items[this.active + 1].status = 'loading'
              this.set('items.' + (this.active + 1) +'.status', 'loading');
            }
            else if (typeof this._responseList[this.active + 1] === typeof undefined) {
              this.items[this.active + 1].status = 'loading'
              this.set('items.' + (this.active + 1) +'.status', 'loading');
            }
            this.active = this.active + 1;
            this.fire('progress-state-change', {state: this.state});
          }
          else if (this.items.length == this.active + 1) {
            // fire an event change to indicate that this happened
            this.state = 'complete';
            this.fire('progress-state-change', {state: this.state});
            this.items[this.active].status = 'finished';
            this.set('items.' + (this.active) +'.status', 'finished');
          }
        }
        else {
          this.set('items.' + this.active +'.value', newp);
        }
      },
      /**
       * Modify items and update template binding correctly.
       */
      updateItems: function (op, item) {
        var response = false;
        if (op == 'push') {
          this.push('items', item);
          response = true;
        }
        else if (op == 'pop') {
          response = this.pop('items');
        }
        else if (op == 'splice') {
          this.splice('items', this.items.length, 0, item);
          response = true;
        }
        // force active to reprocess
        const active = this.active;
        this.set('active', 0);
        this.set('active', active);
        return response;
      },
    });
  </script>
</dom-module>