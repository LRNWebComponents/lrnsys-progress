<link rel="import" href="imports.html">

<!--
`lrnsys-progress`
A LRN element

@demo demo/index.html
-->

<dom-module id="lrnsys-progress">
  <template>
    <style>
      :host {
        display: block;
      }
      #circle-container {
        display: flex;
        justify-content:space-between;
        list-style: none;
        margin: -1.4em 0 0 0;
        padding: 0;
      }
      paper-progress {
        --paper-progress-height: .5em;
        --paper-progress-transition-duration: 0.5s;
        --paper-progress-transition-timing-function: ease;
        --paper-progress-transition-delay: .4s;
        width: 100%;
      }
      lrnsys-progress-circle {
        --lrnsys-progress-circle-size: 2.5em;
      }
    </style>
    <paper-progress id="progress" value="[[overallPercentage]]"></paper-progress>
    <ul id="circle-container">
      <template is="dom-repeat" items="[[items]]" as="item">
        <li class="circle-node">
          <lrnsys-progress-circle active="[[_isActive(index, active)]]" step="[[index]]" label="[[item.title]]" icon="[[item.icon]]" icon-complete="[[item.iconComplete]]" url="[[item.url]]" status="[[item.status]]" value="[[item.value]]" max="[[item.max]]" width="4"></lrnsys-progress-circle>
        </li>
      </template>
    </ul>

  </template>

  <script>
    Polymer({
      is: 'lrnsys-progress',
      listeners: {
        'active-node-changed': '_activeChanged',
      },
      properties: {
        /**
         * Items to display to visualize the progression.
         */
        items: {
          type: Array,
          value: [],
          notify: true,
        },
        /**
         * Items displayed at specific points on the progression.
         * These aren't filled up but place points along the progression
         * which can help people see where they are relative to other
         * factors such as % complete as a tick mark or icon.
         */
        keyItems: {
          type: Array,
          value: [],
          notify: true,
        },
        /**
         * ID of the active item.
         */
        active: {
          type: Number,
          value: 0,
          reflectToAttribute: true,
        },
        /**
         * Whether to automatically make disabled items available
         * or not when the previous one was just complete.
         */
        progressiveUnlock: {
          type: Boolean,
          value: true,
          reflectToAttribute: true,
          notify: true,
        },
        /**
         * State of progress in the current progression
         */
        state: {
          type: String,
          reflectToAttribute: true,
        },
        /**
         * How far is the user through this series of items.
         */
        overallPercentage: {
          type: Number,
          computed: '_overallPercentageCompute(items, active)',
          reflectToAttribute: true,
        },
      },
      /**
       * Simple boolean for whatever is active currently.
       */
      _isActive: function (index, active) {
        return index === active;
      },
      /**
       * Active item has changed, set the rest of the data to match.
       */
      _activeChanged: function (e) {
        this.active = e.target.step;
        this.items.forEach((element, index, array) => {
          if (this.items[index].status == 'disabled') {
            // do nothing, it's disabled unless....
            if (index != 0 && this.progressiveUnlock && this.items[index-1].status == 'complete') {
              this.items[index].status = 'available'
              this.set('items.' + index +'.status', 'available');
            }
          }
          else if (index <= this.active) {
            this.items[index].status = 'complete'
            this.set('items.' + index +'.status', 'complete');
          }
          else {
            this.items[index].status = 'available'
            this.set('items.' + index +'.status', 'available');
          }
        });
      },
      /**
       * Calculate the overall percentage competed.
       * This forms the line that's connecting the steps.
       */
      _overallPercentageCompute: function (items, active) {
        this.$.progress.classList.add('transiting');
        this.state = 'active item is ' + active;
        this.fire('progress-status-change', {status: this.state, active: items[active]});
        return (active / (items.length-1)) * 100;
      },
      /**
       * Change the percentage for the active item.
       */
      changePercentage: function (percentage) {
        if (percentage >= this.items[this.active].max) {
          this.set('items.' + this.active +'.value', this.items[this.active].max);
          this.set('items.' + this.active +'.status', 'complete');
          // ensure we still have more items to go in the list
          if (this.items.length > (this.active + 1)) {
            // if we have progressive unlocking then set the next thing available
            if (this.active != 0 && this.progressiveUnlock && this.items[this.active].status == 'complete' && this.items[this.active+1].status == 'disabled') {
              this.items[this.active + 1].status = 'available'
              this.set('items.' + (this.active + 1) +'.status', 'available');
            }
            this.active = this.active + 1;
            this.set('items.' + this.active +'.value', 0);
            this.fire('progress-status-change', {status: this.state});
          }
          else if (this.items.length == this.active + 1) {
            // fire an event change to indicate that this happened
            this.state = 'complete';
            this.fire('progress-status-change', {status: this.state});
          }
        }
        else {
          this.set('items.' + this.active +'.value', percentage);
        }
      },
      /**
       * Modify items and update template binding correctly.
       */
      updateItems: function (op, item) {
        var response = false;
        if (op == 'push') {
          this.push('items', item);
          response = true;
        }
        else if (op == 'pop') {
          response = this.pop('items');
        }
        else if (op == 'splice') {
          this.splice('items', this.items.length, 0, item);
          response = true;
        }
        // force active to reprocess
        const active = this.active;
        this.set('active', 0);
        this.set('active', active);
        return response;
      },
    });
  </script>
</dom-module>